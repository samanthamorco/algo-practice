How to find all pairs on an integer array whose sum is equal to given number?

Example input:
int[] array = {9,1,3,4,6,7,2,8,2};
int sum = 10;

Map<int,int> pairs = new HashMap<int,int>();
for (int i : array) {
	pairs.put(i, "");
}
for (int i : array) {
	int additive = sum - element;
	if (pairs.get(i) == "") {
		pairs.put(i, additive.toString());
		System.out.println(element.toString() + ", " + additive.toString());
		if (pairs.get(additive)) {
			pairs.remove(additive);
		}
	}
}


How to find repeated numbers in an array if it contains duplicates?

int[] array = {2,30,39,28,28,2,1,3,4,5,28};
Map<int,int> duplicates = new HashMap<int,int>();

for (int element : array) {
	if (duplicates.get(element)) {
		duplicates.set(duplicates.get(element) + 1);
	}
	duplicates.add(element, 1);
}

for (int e : duplicates) {
	if (duplicates.get(element) > 1) {
		System.out.println(e.getKey() + ": " + duplicates.get(element));
	}
}


Quicksort algorithm:

int[] array = {9,1,3,4,6,7,2,8,2};

public void quickSort(int leftIndex, int rightIndex) {

	if (rightIndex - leftIndex <= 0){
		return;
	}

	int pivotPosition = partition(array);
	quickSort(leftIndex, pivotPosition - 1);
	quickSort(pivotPosition + 1, rightIndex);
}

public int parition(int[] array) {
	int pivot = array[array.length() - 1];
	int leftPointer = 0;
	int rightPointer = pivot - 1;

	do {
		while (array[leftPointer] < pivot) {
			leftPointer = leftPointer + 1;
		}

		while (array[rightPointer] > pivot) {
			rightPointer = rightPointer - 1;
		}

		if (leftPointer >= rightPointer) {
			int temp = array[leftPointer];
			array[leftPointer] = pivot;
			pivot = temp;
			break;
		}
		else {
			int temp = array[leftPointer];
			array[leftPointer] = array[rightPointer];
			array[rightPointer] = temp;
		}
	} while (true);

	return leftPointer;
}


How to find kth smallest element in unsorted array?
Quickselect problem:

array = [1, 6, 4, 3, 2, 7, 10, 4, 54, 4]

def partition(left_index, right_index):
    pivot_index = right_index
    left_pointer = left_index
    right_pointer = right_index - 1

    while True:
        while array[left_pointer] <= array[pivot_index] and left_pointer != right_index:
            left_pointer += 1
        while array[right_pointer] >= array[pivot_index] and right_pointer != left_index:
            right_pointer -= 1

        if left_pointer >= right_pointer:
            temp_value = array[left_pointer]
            array[left_pointer] = array[pivot_index]
            array[pivot_index] = temp_value
            return left_pointer
        else:
            temp_value = array[left_pointer]
            array[left_pointer] = array[right_pointer]
            array[right_pointer] = temp_value

def quick_select(desired_index, left_index, right_index):

    if right_index - left_index <= 0:
        return array[left_index]

    pivot_index = partition(left_index, right_index)

    if pivot_index > desired_index:
        return quick_select(desired_index, left_index, pivot_index - 1)
    elif pivot_index < desired_index:
        return quick_select(desired_index, pivot_index + 1, right_index)
    else:
        return array[pivot_index]

quick_select(2, 0, len(array) - 1)


How to find common elements in three sorted arrays?

Examples:
input1 = {1, 5, 10, 20, 40, 80}
input2 = {6, 7, 20, 80, 100}
input3 = {3, 4, 15, 20, 30, 70, 80, 120}
Output: 20, 80

intersection = []
counter1 = 0
counter2 = 0
counter3 = 0

HashSet<int> input1set = new HashSet<int>();
HashSet<int> input2set = new HashSet<int>();

for (int i : input1) {
    input1set.put(i);
}
for (int i : input2) {
    input2set.put(i);
}
for (int i : input3) {
    if (input1set.get(i)) {
        if (input2set.get(i)) {
            System.out.println(i);
        }
    }
}


How find the first repeating element in array of integers?

input = [10, 5, 3, 4, 3, 5]
duplicates = {}

for element in input:
    if element in duplicates:
        print(element)
        break
    else:
        duplicates[element] = 1


How to find the first non-repeating element in an array of integers?

List<Integer> input = new ArrayList<Integer>(Arrays.asList(10, 5, 3, 4, 3, 5, 6));
HashMap<Integer,ArrayList<Integer> duplicates = new HashMap<Integer,ArrayList<Integer>>();

for (int i=0, i < input.size(), i++) {
    if(duplicates.containsKey(element)) {
        duplicates.get(element)[0]++;
    }
    else {
        ArrayList<Integer> occurAndIndex = new ArrayList<Integer>();
        occurAndIndex.add(0, 1);
        occurAndIndex.add(1, i);
        duplicates.put(element, occurAndIndex);
    }
}

int tempLowestIndex = inputs.size();
int tempElement = 0;

for (Integer element : duplicates.entrySet()) {
    if(element.getValue()[0]) == 1 {
        if(element.getValue()[1] < tempLowestIndex) {
            tempElement = element.getKey();
        }
    }
}

System.out.println(tempElement);


Create a Pig Latiner

1. If a word starts with a consonant and a vowel, put the first letter of the word at the end of the word and add "ay."
Example: Happy = appyh + ay = appyhay

2. If a word starts with two consonants move the two consonants to the end of the word and add "ay."
Example: Child = Ildch + ay = Ildchay

3. If a word starts with a vowel add the word "way" at the end of the word.
Example: Awesome = Awesome +way = Awesomeway

pl_string = 'happy'
vowels = {'a', 'e', 'i', 'o', 'u'}

if pl_string[0].lower() not in vowels and pl_string[1].lower() in vowels:
    first_letter = pl_string[0]
    print(pl_string[1:] + '-' + pl_string[0] + 'ay')
elif pl_string[0].lower() in vowels:
    print(pl_string + '-way')
else:
    for index, letter in enumerate(pl_string):
        if letter in vowels:
            print(pl_string[index:] + '-' + pl_string[:index] + 'ay')


Change Return Program - The user enters a cost and then the amount of money given. The program will figure out the change and the number of quarters, dimes, nickels, pennies needed for the change.

cost = 9.48
given = 10

change_back = {'pennies': 0, 'nickels': 0, 'dimes': 0, 'quarters': 0}
change = {25: 'quarters', 1: 'dimes', 05: 'nickels', 01: 'pennies'}
remainder = (given * 100) - (cost * 100)

for denomination in change:
    while remainder >= denomination:
        change_back[change[denomination]] += 1
        remainder -= denomination

for k, v in change_back.items():
    print(k)
    print(v)

































