How to find common elements in three sorted arrays?

Examples:
input1 = {1, 5, 10, 20, 40, 80}
input2 = {6, 7, 20, 80, 100}
input3 = {3, 4, 15, 20, 30, 70, 80, 120}
Output: 20, 80

HashSet<int> input1set = new HashSet<int>();
HashSet<int> input2set = new HashSet<int>();

for (int i : input1) {
	input1set.put(i);
}
for (int i : input2) {
	input2set.put(i);
}
for (int i : input3) {
	if (input1set.get(i)) {
		if (input2set.get(i)) {
			System.out.println(i);
		}
	}
}


How to find all pairs on an integer array whose sum is equal to given number?

Example input:
int[] array = {9,1,3,4,6,7,2,8,2};
int sum = 10;

Map<int,int> pairs = new HashMap<int,int>();
for (int i : array) {
	pairs.put(i, "");
}
for (int i : array) {
	int additive = sum - element;
	if (pairs.get(i) == "") {
		pairs.put(i, additive.toString());
		System.out.println(element.toString() + ", " + additive.toString());
		if (pairs.get(additive)) {
			pairs.remove(additive);
		}
	}
}


How to find repeated numbers in an array if it contains duplicates?

int[] array = {2,30,39,28,28,2,1,3,4,5,28};
Map<int,int> duplicates = new HashMap<int,int>();

for (element : array) {
	if (duplicates.get(element)) {
		duplicates.set(duplicates.get(element) + 1);
	}
	duplicates.add(element, 1);
}

for (e : duplicates) {
	if (duplicates.get(element) > 1) {
		System.out.println(e.getKey() + ": " + duplicates.get(element));
	}
}


Quicksort algorithm:

int[] array = {9,1,3,4,6,7,2,8,2};

public void quickSort(int leftIndex, int rightIndex) {

	if (rightIndex - leftIndex <= 0){
		return;
	}

	int pivotPosition = partition(array);
	quickSort(leftIndex, pivotPosition - 1);
	quickSort(pivotPosition + 1, rightIndex);
}

public int parition(int[] array) {
	int pivot = array[array.length() - 1];
	int leftPointer = 0;
	int rightPointer = pivot - 1;

	do {
		while (array[leftPointer] < pivot) {
			leftPointer = leftPointer + 1;
		}

		while (array[rightPointer] > pivot) {
			rightPointer = rightPointer - 1;
		}

		if (leftPointer >= rightPointer) {
			int temp = array[leftPointer];
			array[leftPointer] = pivot;
			pivot = temp;
			break;
		}
		else {
			int temp = array[leftPointer];
			array[leftPointer] = array[rightPointer];
			array[rightPointer] = temp;
		}
	} while (true);

	return leftPointer;
}


How to find kth smallest element in unsorted array?
Quickselect problem:

array = [1, 6, 4, 3, 2, 7, 10, 4, 54, 4]

def partition(left_index, right_index):
    pivot_index = right_index
    left_pointer = left_index
    right_pointer = right_index - 1

    while True:
        while array[left_pointer] <= array[pivot_index] and left_pointer != right_index:
            left_pointer += 1
        while array[right_pointer] >= array[pivot_index] and right_pointer != left_index:
            right_pointer -= 1

        if left_pointer >= right_pointer:
            temp_value = array[left_pointer]
            array[left_pointer] = array[pivot_index]
            array[pivot_index] = temp_value
            return left_pointer
        else:
            temp_value = array[left_pointer]
            array[left_pointer] = array[right_pointer]
            array[right_pointer] = temp_value

def quick_select(desired_index, left_index, right_index):

    if right_index - left_index <= 0:
        return array[left_index]

    pivot_index = partition(left_index, right_index)

    if pivot_index > desired_index:
        quick_select(desired_index, left_index, pivot_index - 1)
    elif pivot_index < desired_index:
        quick_select(desired_index, pivot_index + 1, right_index)
    else:
        print(array[pivot_index])

quick_select(2, 0, len(array) - 1)








